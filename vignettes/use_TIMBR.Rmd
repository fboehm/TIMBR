---
title: "Getting Started with TIMBR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{use_TIMBR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=5, fig.height=5) 
```

## Overview

TIMBR is an R package for inferring an allelic series of haplotypes at a locus in a multiparental population. This vignette demonstrates how to get started using data from the first example in the [manuscript](https://www.biorxiv.org/content/10.1101/2020.05.23.112326v2).

## Installing from GitHub
```{r, eval=F}
devtools::install_github("wesleycrouse/TIMBR")
```

## Loading the package and example data
```{r}
library(TIMBR)
data(mcv.data)
```

## Formatting data
The input data for TIMBR includes a vector `y` of quantitative trait observations
```{r}
y <- mcv.data$y
head(y, 10)
```
and a list `prior.D` which specifies prior haplotype-pair (diplotype) state probabilities.
```{r}
prior.D <- mcv.data$prior.D
str(prior.D)
```
`prior.D` includes a matrix of diplotype state probabilities `P` for all individuals and an additive design matrix `A` that maps diplotype states to half-counts of haplotype dosages. The option `fixed.diplo=TRUE` fixes each diplotype state to its prior maximum to speed computation. In this example, there are 131 individuals, 36 possible diplotype states, 8 different haplotypes, and diplotype states will be sampled rather than fixed.

The order of rows in `P` must match the order of observations in `y`. When inputting your own data, make sure that `A` is correctly specified to match the order of columns in `P`.  Here, the columns in `P` (and consequently, the rows in `A`) use the default order in 'HAPPY'. For example, the first rows of `A` are:
```{r}
prior.D$A[1:14,]
```
The default order in 'qtl2' is different. To generate an additive design matrix for use with 'qtl2' data, use the function `additive.design`. The row and column names in `P` and `A` are for clarity; they are not used by TIMBR.

## Haplotype-based association

TIMBR requires a prior distribution for the allelic series. To begin, we implement a standard haplotype-based association model that assumes the allelic series is known and that all haplotypes are functionally distinct from one another. 
```{r}
prior.M.hap <- mcv.data$prior.M$fixed
str(prior.M.hap)
```
`prior.M` is a list where `model.type="fixed"` specifies that the allelic series is fixed to a single value, and `M.IDs="0,1,2,3,4,5,6,7"`specifies an allelic series where all 8 haplotypes are functionally distinct. 

We call TIMBR using this prior and visualize the haplotype effects.
```{r}
results.hap <- TIMBR(y, prior.D, prior.M.hap, verbose=F, samples=100, samples.ml=100)
TIMBR.plot.haplotypes(results.hap)
```

We also report the natural log Bayes factor (lnBF) in favor of this model against a null where all haplotypes are functionally identical (i.e. there is no genetic effet).
```{r}
results.hap$ln.BF
```

## Setting the allelic series to a specific value

Based on the previous result, it may be reasonable to assume that the allelic series is actually biallelic, with one functional allele comprised of haplotypes B,D,E and the other allele comprised of the other haplotypes. We can specify this allelic series similarly. 
```{r}
prior.M.biallelic <- list(model.type="fixed", 
                          M.IDs="0,1,0,1,1,0,0,0")
```

We call TIMBR assuming this biallelic contrast, report the first ten posterior samples of the haplotype effects, and visualize the haplotype effects against the previous haplotype-based model.
```{r}
results.biallelic <- TIMBR(y, prior.D, prior.M.biallelic, verbose=F, samples=100, samples.ml=100)
results.biallelic$post.hap.effects[1:10,]
TIMBR.plot.haplotypes(results.biallelic, TIMBR.output.bkgrd=results.hap)
```

The posterior samples show that haplotype effects are now identical within alleles. The visualization shows that they are also estimated with more certainty because there are fewer effect parameters (two) than in the haplotype-based model (eight). We also calculate the lnBF in favor of this biallelic model against the previous haplotype-based model.
```{r}
results.biallelic$ln.BF - results.hap$ln.BF
```

In this way, TIMBR can be used for a fully-Bayesian implementaiton of merge analysis. See the manuscript for more details.

## Modeling the allelic series with a uniform prior distribution

Often, we do not expect all haplotypes to be functionally distint, but we also do not know the correct allelic series configuration with certainty. Using TIMBR, we can set a prior distribution over all possible allelic series configurations and estimate a posterior distribution. A naive first approach is to assume a uniform distribution where all allelic series are equally likely *a priori*. This is specifed as 
```{r}
prior.M.uniform <- mcv.data$prior.M$uniform
str(prior.M.uniform)
```

We call TIMBR assuming a uniform prior distribution and report the top ten posterior allelic series.
```{r}
results.uniform <- TIMBR(y, prior.D, prior.M.uniform, verbose=F, samples=100, samples.ml=100)
as.matrix(head(results.uniform$p.M.given.y, 10))
```

The top allelic series configuration has three functional alleles (A,G,H vs. B,D,E vs. C,F), the biallelic contrast from the previous section is ranked fourth, and posterior certainty is generally low.

## Modeling the allelic series with a Chinese restaurant process prior distribution

A uniform distribution over allelic series implies a strong prior belief in an intermediate number of alleles, but this is unreasonable, for example, if we have a prior expectation that many allelic series are biallelic. TIMBR implements a flexible prior distribution over allelic series called a Chinese restaurant process (CRP). The CRP has a concentration parameter $\alpha$ that controls the prior number of functional alleles. At the limits, $\alpha=0$ implies a null model with only one functional allele, and $\alpha=\infty$ implies the haplotype-based model where all haplotypes are functionally distinct. The approach used in the manuscript places a gamma prior distribution on the concentration parameter with the following parameters.
```{r}
prior.M.crp <- mcv.data$prior.M$crp
str(prior.M.crp)
```
It is also possible to set $\alpha$ to a fixed value, see `mcv.data$prior.M$crp.fixed` for an example.

We call TIMBR using the CRP and this gamma prior distribution for the concentration parameter and report the top ten posterior allelic series.
```{r}
results.crp <- TIMBR(y, prior.D, prior.M.crp, verbose=F, samples=100, samples.ml=100)
as.matrix(head(results.crp$p.M.given.y, 10))
```

The biallelic contrast from earlier is now the top posterior allelic series with over 50% probability. This is because our prior distribution places considerable weight on smaller numbers of functional alleles. We also visualize the haplotype effects against haplotype-based approach from earlier.
```{r}
TIMBR.plot.haplotypes(results.crp, TIMBR.output.bkgrd=results.hap)
```

The haplotype effects using the CRP are again more certain, but they retain long tails that span much of the range of the effect estimates from the haplotype-based model.

## Computing the prior distribution with Ewens's sampling formula

The CRP implictly assumes that the haplotypes are equally related and that the relationship between them is unknown. Specifically, Ewens's sampling formula describes the CRP as the distribution over partitions (i.e. allelic series) induced by functional mutations on an unknown coalescent tree with the haplotypes at the leaves. TIMBR leverages this relationship to define a prior distribution for the allelic series that is conditional on a single tree (or set of trees), rather than an unknown coalescent tree. 

The example data includes samples of coalescent trees at the causal locus for this QTL in `mcv.data$trees`. This is an object of class `multiphylo`, which is defined by the 'ape' package. We visualize the first tree sample using 'ape'.
```{r}
library(ape)
trees <- mcv.data$trees
plot.phylo(trees[[1]])
```

The tree indicates that haplotypes B,D,E are more closely related to each other and then the other haplotypes. Based on this relationship, and before observing any additional phenotype data, we intuitively expect that haplotypes B,D,E are more likely to be functionally identical and distinct from the other haplotypes. Ewens's sampling formula formalizes this intuition by assuming that functional mutations occur on the tree in proportion to branch length. The function `ewenss.calc` enumerates all possible combinations of mutated tree branch, calculates prior probabilities, and returns a prior distribution over allelic series that is conditional on this tree. 

We use the same prior on the concentration parameter $\alpha$ (in this context, the functional mutation rate on the branches) as before, examine the output, and we display the ten allelic series with the highest prior probability.
```{r}
prior.alpha <- list(type="gamma", 
                    shape=1, 
                    rate=2.333415)
prior.M.tree.1 <- ewenss.calc(trees[[1]], prior.alpha)
str(prior.M.tree.1)
data.frame(M=prior.M.tree.1$M.IDs[1:10], post.prob=exp(prior.M.tree.1$ln.probs[1:10]))
```

As expected, there is now considerable prior weight given to allelic series that results from functional mutations on longer branches of the tree. It is possible (though somewhat computationally intensive) to compute the prior distribution for all the samples in `trees` and average them to accomodate uncertainty in the tree. We provide code for this here, and it is also precomputed in `mcv.data$prior.M$list`. 

```{r}
# trees.prior <- lapply(trees, ewenss.calc, prior.alpha=prior.alpha)
# trees.prior <- unlist(lapply(trees.prior, function(x){ln.probs <- x$ln.probs; 
#                                                       names(ln.probs) <- x$M.IDs; 
#                                                       ln.probs}))
# trees.prior <- tapply(trees.prior, names(trees.prior), matrixStats::logSumExp) - log(length(trees))
# prior.M.trees <- list(model.type="list", 
#                       M.IDs=names(trees.prior), 
#                       ln.probs=as.numeric(unname(trees.prior)), 
#                       hash.names=T)

prior.M.trees <- mcv.data$prior.M$list
```

We can also use `ewenss.calc` to precompute the prior distribution under the CRP, alternatively formatted as this list-type input. Calling TIMBR with this prior is equivalent to using `prior.M.crp` from earlier. 
```{r}
prior.M.crp.list <- ewenss.calc(8, prior.alpha)
```

To convince yourself of the relationship between the CRP and Ewens's sampling formula, try sampling a collection of random coalescent trees using the code below, compute and average their prior distributions as we just described, and compare the result with `prior.M.crp.list`. 
```{r}
# trees.coal <- replicate(1000, rcoal(8, LETTERS[1:8]), simplify=F)
```

## Modeling the allelic series with a tree-informed prior distribution

It is straightforward to call TIMBR with a tree-informed prior distribution and reporting the posterior allelic series.
```{r}
results.crp.trees <- TIMBR(y, prior.D, prior.M.trees, verbose=F, samples=1000, samples.ml=1000)
as.matrix(head(results.crp.trees$p.M.given.y, 10))
```

Posterior certainty is higher relative to the CRP because we have introduced additional prior information about haplotype relatedness. We calculate a lnBF in favor of this tree-informed prior against the CRP, which implictly assumes an unknown coalescent tree.
```{r}
results.crp.trees$ln.BF - results.crp$ln.BF
```

## Visualizing the prior distribution of number of alleles

Earlier, we mentioned that our specified CRP prior distribution favors fewer alleles relative to the uniform prior distribution. Here, we provide code to visualize the prior distribution of number of alleles using the CRP. Try changing the parameters of the gamma prior for $\alpha$ (or fixing $\alpha$ to a single value) and see how the prior distribution changes.

```{r}
prior.alpha <- list(type="gamma", shape=1, rate=2.333415)
# prior.alpha <- list(type="fixed", alpha=1)

prior.M.crp.list <- ewenss.calc(8, prior.alpha)
number.alleles <- sapply(prior.M.crp.list$M.IDs, 
                         function(x){max(as.numeric(unlist(strsplit(x, split=","))))+1})
prior.number.alleles.uniform <- table(number.alleles) / length(number.alleles)
prior.number.alleles.crp <- exp(tapply(prior.M.crp.list$ln.probs, number.alleles, 
                                       matrixStats::logSumExp))

plot(1:8, prior.number.alleles.crp, type="l", lty=5, col="white", 
     ylim=c(0,1), ylab="Prior Probability", xlab="Number of Alleles", 
     main="Prior Distribution of Alleles")
lines(1:8, prior.number.alleles.crp, lty=5, col="orange")
points(1:8, prior.number.alleles.crp, pch=22, bg="orange")
lines(1:8, prior.number.alleles.uniform, lty=5, col="darkcyan")
points(1:8, prior.number.alleles.uniform, pch=22, bg="darkcyan")

legend(1, legend=c("Uniform", "CRP"), col=c("darkcyan", "orange"), lty=5)
```

## Approximating Bayes factors for alternative prior distributions from previous results

It is possible to approximate lnBFs for alternative allelic series prior distributions using the results of a previous TIMBR run and the `TIMBR.approx` function. This is useful for analyses that must be repeated many times for a single locus (e.g. evaluating multiple variants for merge analysis), or more generally, for quickly evaluating evidence in favor of alternative priors. For illustration, we approximate the lnBF for all possible biallelic contrasts using our CRP results, and we compare these with the biallelic result we generated earlier.
```{r}
TIMBR.approx(results.crp, "merge")
results.biallelic$ln.BF
```

Note that this is only an approximation. In this case, only one biallelic series was observed in the CRP posterior, so approximations for all other biallelic contrasts underflow and are not reported.

## Other options

The `TIMBR` function has several other useful options. Covariates can be specified using the `Z` matrix; just make sure that the first column of the matrix is a vector of ones. It is also possible to use strain means for `y` and specify the number of replicates using vector `W`. Finally, it is possible to control shrinkage in the allele effects by varying `prior.phi.v`; see the manuscript for a description of the hyperparameter $\nu$.
